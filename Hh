
-- Services
local library = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Cam = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")

-- Create Main GUI Window
local PepsisWorld = library:CreateWindow({
    Name = "UndetectedWare Beta",
    Themeable = {
        Info = "Discord Server"
    }
})

-- Tabs and Sections for GUI
local GeneralTab = PepsisWorld:CreateTab({ Name = "General" })
local AimbotTab = PepsisWorld:CreateTab({ Name = "Aimbot" })
local MiscTab = PepsisWorld:CreateTab({ Name = "Miscellaneous" })
local ESPTab = PepsisWorld:CreateTab({ Name = "ESP" })

-- General Features
local FarmingSection = GeneralTab:CreateSection({ Name = "Player" })

-- Infinite Stamina
local infiniteStaminaEnabled = false
local staminaLoop

FarmingSection:AddToggle({
    Name = "Infinite Stamina",
    Flag = "InfiniteStaminaToggle",
    Callback = function(enabled)
        infiniteStaminaEnabled = enabled
        if infiniteStaminaEnabled then
            local function OnLocalCharacterAdded(Character)
                if not Character then return end
                repeat wait() until Character:FindFirstChildOfClass("Humanoid")

                -- Get stamina-related tables
                local StaminaTbl = {}
                for i, v in pairs(getgc(true)) do
                    if type(v) == "table" and rawget(v, "S") then
                        table.insert(StaminaTbl, v)
                    end
                end

                -- Infinite stamina loop with debounce
                if staminaLoop then staminaLoop:Disconnect() end
                staminaLoop = RunService.RenderStepped:Connect(function()
                    if infiniteStaminaEnabled then
                        for _, Stamina in pairs(StaminaTbl) do
                            Stamina.S = 100
                        end
                    else
                        staminaLoop:Disconnect()
                    end
                end)
            end

            LocalPlayer.CharacterAdded:Connect(OnLocalCharacterAdded)
            if LocalPlayer.Character then
                OnLocalCharacterAdded(LocalPlayer.Character)
            end
        else
            if staminaLoop then
                staminaLoop:Disconnect()
            end
        end
    end
})

-- Other functionalities (similar structure with debounced loops and disconnects as above)
-- For each function with a loop, ensure you disconnect the loop when disabled or on respawn.

-- Cleanup after respawn to prevent duplicated connections
LocalPlayer.CharacterAdded:Connect(function()
    if staminaLoop then staminaLoop:Disconnect() end
    if tpwalkLoop then tpwalkLoop:Disconnect() end
    if spinLoop then spinLoop:Disconnect() end
end)



local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local tpwalking = false  -- Variable to track whether tpwalk is active
local hb = RunService.Heartbeat  -- Reference to Heartbeat event

-- Function to start tpwalk
local function startTpWalk(speaker, speed)
    tpwalking = true
    local chr = speaker.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

    while tpwalking and chr and hum and hum.Parent do
        local delta = hb:Wait()  -- Wait for next heartbeat frame
        if hum.MoveDirection.Magnitude > 0 then  -- Check if player is moving
            if speed and tonumber(speed) then
                -- Move character by teleporting in the direction they are walking
                chr:TranslateBy(hum.MoveDirection * tonumber(speed) * delta * 10)
            else
                -- Default movement speed if no specific speed is provided
                chr:TranslateBy(hum.MoveDirection * delta * 10)
            end
        end
    end
end

-- Function to stop tpwalk
local function stopTpWalk()
    tpwalking = false
end

-- Toggle for tpwalk using GUI toggle
FarmingSection:AddToggle({
    Name = "Teleport Walk",
    Flag = "TpWalkToggle",
    Callback = function(enabled)
        local player = Players.LocalPlayer
        if enabled then
            -- Start tpwalk with a specific speed, here 1.5 as an example
            startTpWalk(player, 1.5)
            print("Teleport walk started")
        else
            stopTpWalk()
            print("Teleport walk stopped")
        end
    end
})

-- Bind the toggle function to a key press (optional if needed)
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.T then  -- If "T" key is pressed
        local toggle = not tpwalking
        MiscSection:SetToggle("TpWalkToggle", toggle)  -- Update the toggle state
    end
end)



local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- Variable to store if the spinbot is enabled or not
local spinEnabled = false
local spinning = false

-- Speed of the spin (adjust this as needed)
local spinSpeed = 100

-- Function to handle spinning behavior
local function spinCharacter()
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        while spinEnabled do
            humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
            wait(0.03)  -- Adjust the speed of the spinning
        end
    end
end



FarmingSection:AddToggle({
    Name = "Enable Spinbot",
    Flag = "SpinbotToggle",
    Callback = function(enabled)
        spinEnabled = enabled
        if spinEnabled then
            -- Start spinning when enabled
            if not spinning then
                spinning = true
                spawn(spinCharacter)  -- Start the spinning loop
            end
        else
            -- Stop spinning when disabled
            spinning = false
        end
    end
})

print("Spinbot toggle and script setup completed.")


-- Initialize KillAuraEnabled to false (disabled by default)
local KillAuraEnabled = false
local KillAuraTime = 1  -- Default time value, adjust as needed

-- Function to find the closest humanoid root part within a max distance
local function closestHumanoidRootPart(maxDist)
    local dist = maxDist
    local ret = nil
    for i, v in next, game.Players:GetPlayers() do
        if v ~= game.Players.LocalPlayer then
            if v.Character then
                local chr = v.Character
                if chr:FindFirstChild("HumanoidRootPart") then
                    if chr.Humanoid.Health > 0 then
                        local e = chr.HumanoidRootPart
                        local d = (e.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                        if d < dist then
                            dist = d
                            ret = e
                        end
                    end
                end
            end
        end
    end
    return ret
end

-- The Kill Aura loop
spawn(function()
    while task.wait() do
        if KillAuraEnabled then
            local ClosestHumanoidRootPart = closestHumanoidRootPart(10)
            if not ClosestHumanoidRootPart then continue end
            if not game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
                continue
            end

            -- Execute the Kill Aura
            local KillAuraValue = game:GetService("ReplicatedStorage").Events["XMHH.1"]:InvokeServer(
                "\240\159\154\168",
                tick(),
                game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"),
                "43TRFWJ",
                "Normal",
                tick(),
                true
            )
            wait(KillAuraTime)
            game:GetService("ReplicatedStorage").Events["XMHH2.1"]:FireServer(
                "\240\159\154\168",
                tick(),
                game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"),
                "2389ZFX33",
                KillAuraValue,
                false,
                game:GetService("Players").LocalPlayer.Character["Right Arm"],
                ClosestHumanoidRootPart.Parent:FindFirstChild("Head"),
                ClosestHumanoidRootPart.Parent,
                game:GetService("Players").LocalPlayer.Character["Right Arm"].Position,
                ClosestHumanoidRootPart.Parent:FindFirstChild("Head").Position
            )
        end
    end
end)

-- Watch for tool changes and update KillAuraTime based on the tool's config
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
    Character.ChildAdded:Connect(function(Object)
        if KillAuraEnabled and Object:IsA("Tool") then
            pcall(function()
                KillAuraTime = require(game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool").Config).Mains.E.SwingTime
            end)
        end
    end)
end)

-- Add toggle for Kill Aura
FarmingSection:AddToggle({
    Name = "Enable Kill Aura",
    Flag = "KillAuraToggle",
    Callback = function(enabled)
        KillAuraEnabled = enabled  -- Set the KillAuraEnabled state based on toggle
    end
})



FarmingSection:AddButton({
    Name = "Reset Kill Aura Settings",
    Callback = function()
        KillAuraEnabled = false  -- Disable Kill Aura
        print("Kill Aura has been disabled.")
    end
})

-- Example Button in Miscellaneous Tab
FarmingSection:AddButton({
    Name = "Hitbox Expander",
    Callback = function()loadstring(game:HttpGet("https://raw.githubusercontent.com/Vuubvyc/UNDETECTEDWAREEE/refs/heads/main/Hitbox"))();
    end
})





-- Aimbot Features
local AimbotSection = AimbotTab:CreateSection({ Name = "Aimbot Settings" })
local aimlockEnabled = false
local wallCheckEnabled = false
local fov = 130
local maxDistance = 400
local maxTransparency = 0.1
local teamCheck = false
local aimPart = "Head"  -- Change to "Torso" if needed
local FOVring = Drawing.new("Circle")
FOVring.Visible = false -- Initially hidden
FOVring.Thickness = 2
FOVring.Color = Color3.fromRGB(128, 0, 128)
FOVring.Filled = false
FOVring.Radius = fov
FOVring.Position = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)

AimbotSection:AddToggle({
    Name = "Aimlock",
    Flag = "AimlockEnabled",
    Callback = function(enabled)
        aimlockEnabled = enabled
        FOVring.Visible = enabled -- Show FOV ring when enabled
    end
})

AimbotSection:AddToggle({
    Name = "Wall Check",
    Flag = "WallCheckEnabled",
    Callback = function(enabled)
        wallCheckEnabled = enabled
    end
})

local function updateDrawings()
    if aimlockEnabled then
        FOVring.Position = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    end
end

local function lookAt(target)
    local lookVector = (target - Cam.CFrame.Position).unit
    Cam.CFrame = CFrame.new(Cam.CFrame.Position, Cam.CFrame.Position + lookVector)
end

local function calculateTransparency(distance)
    return (1 - (distance / fov)) * maxTransparency
end

local function isPlayerAlive(player)
    local character = player.Character
    return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
end

local function isPlayerVisibleThroughWalls(player, trg_part)
    if not wallCheckEnabled then
        return true
    end
    local localPlayerCharacter = LocalPlayer.Character
    if not localPlayerCharacter then
        return false
    end
    local part = player.Character and player.Character:FindFirstChild(trg_part)
    if not part then
        return false
    end
    local ray = Ray.new(Cam.CFrame.Position, part.Position - Cam.CFrame.Position)
    local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, { localPlayerCharacter })
    if hit and hit:IsDescendantOf(player.Character) then
        return true
    end
    -- Fallback to a nearby position if the direct ray doesn't hit
    local direction = (part.Position - Cam.CFrame.Position).unit
    local nearRay = Ray.new(Cam.CFrame.Position + direction * 2, direction * maxDistance)
    local nearHit, _ = workspace:FindPartOnRayWithIgnoreList(nearRay, { localPlayerCharacter })
    return nearHit and nearHit:IsDescendantOf(player.Character)
end

local function getClosestPlayerInFOV()
    local nearest = nil
    local last = math.huge
    local playerMousePos = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    local localPlayer = Players.LocalPlayer
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and (not teamCheck or player.Team ~= localPlayer.Team) and isPlayerAlive(player) then
            local part = player.Character and player.Character:FindFirstChild(aimPart)
            if part then
                local ePos, isVisible = Cam:WorldToViewportPoint(part.Position)
                local distance = (Vector2.new(ePos.x, ePos.y) - playerMousePos).Magnitude
                if distance < last and isVisible and distance < fov and distance < maxDistance and isPlayerVisibleThroughWalls(player, aimPart) then
                    last = distance
                    nearest = player
                end
            end
        end
    end
    return nearest
end

-- Main Aimlock Logic
RunService.RenderStepped:Connect(function()
    updateDrawings()

    if aimlockEnabled then
        local closest = getClosestPlayerInFOV()
        if closest and closest.Character:FindFirstChild(aimPart) then
            lookAt(closest.Character[aimPart].Position)
            local ePos, isVisible = Cam:WorldToViewportPoint(closest.Character[aimPart].Position)
            local distance = (Vector2.new(ePos.x, ePos.y) - (Cam.ViewportSize / 2)).Magnitude
            FOVring.Transparency = calculateTransparency(distance)
        else
            FOVring.Transparency = maxTransparency
        end
    else
        FOVring.Transparency = maxTransparency -- Set to max transparency when not enabled
    end
end)



-- Chams Features
local chamsEnabled = false
local fillColor = Color3.fromRGB(175, 25, 255)
local fillTransparency = 0.5
local outlineColor = Color3.fromRGB(255, 255, 255)
local outlineTransparency = 0
local storage = Instance.new("Folder", CoreGui)
storage.Name = "Highlight_Storage"

local function applyChams(player)
    if not chamsEnabled then return end

    local highlight = storage:FindFirstChild(player.Name)
    if not highlight then
        highlight = Instance.new("Highlight")
        highlight.Name = player.Name
        highlight.Parent = storage
    end

    highlight.FillColor = fillColor
    highlight.FillTransparency = fillTransparency
    highlight.OutlineColor = outlineColor
    highlight.OutlineTransparency = outlineTransparency

    if player.Character then
        highlight.Adornee = player.Character
    end

    player.CharacterAdded:Connect(function(character)
        highlight.Adornee = character
    end)
end

local function removeChams(player)
    local highlight = storage:FindFirstChild(player.Name)
    if highlight then
        highlight:Destroy()
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        applyChams(player)
    end)
end)

for _, player in pairs(Players:GetPlayers()) do
    applyChams(player)
end

Players.PlayerRemoving:Connect(removeChams)

-- Chams Toggle and Color Controls
local ChamsSection = ESPTab:CreateSection({ Name = "Chams Settings" })
ChamsSection:AddToggle({
    Name = "Enable Chams",
    Flag = "ChamsEnabled",
    Callback = function(enabled)
        chamsEnabled = enabled
        for _, player in pairs(Players:GetPlayers()) do
            if enabled then
                applyChams(player)
            else
                removeChams(player)
            end
        end
    end
})

ChamsSection:AddColorPicker({
    Name = "Chams Fill Color",
    Flag = "FillColor",
    Default = Color3.fromRGB(175, 25, 255),
    Callback = function(color)
        fillColor = color
        for _, player in pairs(Players:GetPlayers()) do
            applyChams(player)
        end
    end
})

ChamsSection:AddColorPicker({
    Name = "Chams Outline Color",
    Flag = "OutlineColor",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(color)
        outlineColor = color
        for _, player in pairs(Players:GetPlayers()) do
            applyChams(player)
        end
    end
})

ChamsSection:AddSlider({
    Name = "Chams Fill Transparency",
    Flag = "FillTransparency",
    Min = 0,
    Max = 1,
    Default = 0.5,
    Callback = function(transparency)
        fillTransparency = transparency
        for _, player in pairs(Players:GetPlayers()) do
            applyChams(player)
        end
    end
})

ChamsSection:AddSlider({
    Name = "Chams Outline Transparency",
    Flag = "OutlineTransparency",
    Min = 0,
    Max = 1,
    Default = 0,
    Callback = function(transparency)
        outlineTransparency = transparency
        for _, player in pairs(Players:GetPlayers()) do
            applyChams(player)
        end
    end
})



-- Miscellaneous Features
local MiscSection = MiscTab:CreateSection({ Name = "Miscellaneous" })

-- Infinite Pepper Spray Functionality
local infinitePepperSprayEnabled = false
MiscSection:AddToggle({
    Name = "Infinite Pepper Spray",
    Flag = "InfinitePepperSprayToggle",
    Callback = function(enabled)
        infinitePepperSprayEnabled = enabled
    end
})

task.spawn(function() 
    RunService.PreRender:Connect(function()
        local Character = LocalPlayer.Character
        if Character then
            local PepperSpray = Character:FindFirstChild("Pepper-spray")
            if PepperSpray then
                local Ammo = PepperSpray:FindFirstChild("Ammo")
                if Ammo then
                    if infinitePepperSprayEnabled then
                        Ammo.MaxValue = math.huge
                        Ammo.MinValue = math.huge
                        Ammo.Value = math.huge
                    end
                end
            end
        end
    end)
end)

-- Fast Pickup Functionality
local fastPickUpEnabled = false
local proximityPrompts = {}

workspace.DescendantAdded:Connect(function(item)
    if item:IsA("ProximityPrompt") then
        proximityPrompts[item] = { originalDuration = item.HoldDuration }
        item.AncestryChanged:Connect(function(_, parent)
            if not parent then proximityPrompts[item] = nil end
        end)
    end
end)

RunService.RenderStepped:Connect(function()
    for prompt, data in pairs(proximityPrompts) do
        if prompt and prompt:IsA("ProximityPrompt") then
            prompt.HoldDuration = fastPickUpEnabled and 0 or data.originalDuration
        end
    end
end)

MiscSection:AddToggle({
    Name = "Fast Pickup",
    Flag = "FastPickUpToggle",
    Callback = function(enabled)
        fastPickUpEnabled = enabled
    end
})

-- Lockpick HBE Functionality
local lockpickHBEEnabled = false
local PlayerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")

PlayerGui.ChildAdded:Connect(function(Child)
    if Child.Name == "LockpickGUI" then
        local Location = Child.MF.LP_Frame.Frames
        for i = 1, 3 do
            local Bar = Location["B"..i].Bar
            Bar.Size = lockpickHBEEnabled and UDim2.new(0, 35, 0, 500) or UDim2.new(0, 35, 0, 30)
        end
    end
end)

MiscSection:AddToggle({
    Name = "Lockpick HBE",
    Flag = "LockpickHBEToggle",
    Callback = function(enabled)
        lockpickHBEEnabled = enabled
        if PlayerGui:FindFirstChild("LockpickGUI") then
            local Location = PlayerGui.LockpickGUI.MF.LP_Frame.Frames
            for i = 1, 3 do
                local Bar = Location["B"..i].Bar
                Bar.Size = lockpickHBEEnabled and UDim2.new(0, 35, 0, 500) or UDim2.new(0, 35, 0, 30)
            end
        end
    end
})

-- Third-Person Toggle
local thirdPersonEnabled = false

local function activateThirdPerson()
    thirdPersonEnabled = true
    LocalPlayer.CameraMode = Enum.CameraMode.Classic -- Sets to third-person mode
end

local function deactivateThirdPerson()
    thirdPersonEnabled = false
    LocalPlayer.CameraMode = Enum.CameraMode.LockFirstPerson -- Sets back to first-person mode
end

local function toggleThirdPerson()
    if thirdPersonEnabled then
        deactivateThirdPerson()
        print("Third-person mode deactivated")
    else
        activateThirdPerson()
        print("Third-person mode activated")
    end
end

-- Toggle Third-Person Mode with Keybind (T for example)
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.T then
        toggleThirdPerson()
    end
end)

-- GUI Toggle for Third-Person Mode (now in Misc)
MiscSection:AddToggle({
    Name = "Third-Person Mode",
    Flag = "ThirdPersonToggle",
    Callback = function(enabled)
        if enabled then
            activateThirdPerson()
        else
            deactivateThirdPerson()
        end
    end
})








-- Define the global variable that controls the loop
getgenv().Instant = false  -- Set to false by default to disable the loop

-- Function to check if the prompt is visible
local function isPromptVisible(prompt)
    local camera = game:GetService("Workspace").CurrentCamera
    local screenPoint = camera:WorldToScreenPoint(prompt.Parent.Position)

    -- Check if the prompt is within the camera's screen bounds
    local viewportSize = camera.ViewportSize
    return screenPoint.X >= 0 and screenPoint.X <= viewportSize.X and screenPoint.Y >= 0 and screenPoint.Y <= viewportSize.Y
end

-- Function to handle the proximity prompt firing loop
local function startInstantLoop()
    while getgenv().Instant do
        wait(0.5)  -- Delay to avoid overloading the script with constant checks
        -- Iterate through all descendants in the workspace
        for _, v in pairs(game:GetService("Workspace"):GetDescendants()) do
            -- Check if the descendant is a ProximityPrompt and within 15 studs of the player
            if v:IsA("ProximityPrompt") and game:GetService("Players").LocalPlayer:DistanceFromCharacter(v.Parent.Position) <= 15 then
                -- Check if the prompt is visible
                if isPromptVisible(v) then
                    -- Fire the ProximityPrompt (simulate pressing the prompt)
                    fireproximityprompt(v, 0)  -- Trigger the prompt
                    wait(0.1)  -- Small delay
                    fireproximityprompt(v, 1)  -- Simulate pressing the button
                end
            end
        end
    end
end

-- Add toggle in GUI to control Instant functionality
MiscSection:AddToggle({
    Name = "Auto Proximity Prompt Lag⚠️",
    Flag = "InstantToggle",
    Callback = function(enabled)
        getgenv().Instant = enabled
        if enabled then
            -- Start the loop if enabled
            spawn(startInstantLoop)
        end
    end
})








print("Instant Proximity Prompt toggle added successfully.")


print("Script loaded successfully.")
